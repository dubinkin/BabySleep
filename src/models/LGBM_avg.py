import pandas as pd
import numpy as np
import lightgbm as lgb


def prepare_data(sleep, window):
    '''
    Prepares data in a format accessible by the model.

    :param sleep: sleep data generated by the load_data.get_sleep function
    :param window: number of 10-minute steps which are included in a given
                   example which are used to make a forecast
    :return: training examples with labels and the data which is used to
             start the next-step forecasting
    '''

    infant = sleep.sleep
    n = infant.shape[0]
    pred_window = 6

    X_train = pd.DataFrame([infant.values[i : i + window]
                            for i in range(n - window)])
    y_train = pd.DataFrame([sum(infant.values[i + window:
                                              i + window + pred_window])
                            for i in range(n - window - pred_window)])

    newsleep = sleep[window:].reset_index(drop=True)
    X_train['time_of_day'] = newsleep.time
    X_train['cos'] = newsleep.time_cos
    X_train['AM/PM'] = newsleep.ampm

    for j in range(6, 6*24+1, 6):
        X_train[str(j) + '_10min'] = pd.DataFrame(
            [infant.values[i + window - j : i + window].sum()
             for i in range(n - window)])

    X_train['N_naps_12hrs'] = pd.DataFrame(
        [abs(pd.Series(infant.values[i + window - 72 :
                                     i + window]).diff()).sum() // 2
         for i in range(n - window)])

    return X_train[: -pred_window], y_train, X_train[-pred_window :]


def train_model(X_train, y_train):
    '''
    Function which fits the model on the training data. The optimal model
    parameters were found previously via a simple grid search.

    :param X_train: training examples
    :param y_train: training labels
    :return: trained lgbm regressor
    '''

    lgbm_reg = lgb.LGBMRegressor(boosting_type='gbdt', num_leaves=20,
                                 max_depth=-1, learning_rate=0.1,
                                 n_estimators=250, subsample_for_bin=200000,
                                 objective=None, class_weight=None,
                                 min_split_gain=0.0, min_child_weight=0.001,
                                 min_child_samples=20, subsample=1.0,
                                 subsample_freq=0, colsample_bytree=1.0,
                                 reg_alpha=0.0, reg_lambda=0.0,
                                 random_state=42, n_jobs=-1,
                                 importance_type='split')

    lgbm_reg.fit(X_train, y_train.values.reshape(-1))

    return lgbm_reg


def prediction(X, model, weights, window, rounding=True):
    '''
    Generates the next-step prediction for based off of the last 6-step data

    :param X: data over the last 6 steps
    :param model: fitted lgbm regressor
    :param weights: weights which are used to combine the predictions from the
                    previous six steps
    :param window: number of 10-minute intervals used to make a prediction
    :param rounding: whether to return the raw prediction, or a binary one
    :return: 1-step ahead forecast
    '''

    if X.shape[0] != 6:
        print("Wrong input data!")
        return -1
    weights = weights / np.sum(weights)

    last_status = X.iloc[-1][window - 1]

    if last_status == 1:
        vec = ((model.predict(X).round() - [5, 4, 3, 2, 1, 0]) > 0).astype(int)
        if rounding:
            return round(np.dot(vec, weights))
        else:
            return np.dot(vec, weights)
    else:
        vec = ((model.predict(X).round() - [5, 4, 3, 2, 1, 0]) < 1).astype(int)
        if rounding:
            return round(1 - np.dot(vec, weights))
        else:
            return 1 - np.dot(vec, weights)


def data_augment(X, prediction, time, window):
    '''
    Function converts the data over the previous 6 steps with the prediction
    for one future step to generate the new data vector for the latest step

    :param X: data for previous most recent 6 steps
    :param prediction: a binary one-step-ahead prediction
    :param time: number of the hour (fractional) of a day at which
                 the latest prediction is made
    :param window: number of 10-minute intervals used to make a prediction
    :return: vector for the updated time step
    '''

    X_c = X.iloc[:, : window]
    X_c = X_c.shift(-1, axis=1)
    X_c.iloc[0, window-1] = prediction
    X_c.index += 1
    time = time + 24/144
    X_c['time_of_day'] = time
    X_c['cos'] = np.cos(2*np.pi * time / 24)
    if time > 12:
        X_c['AM/PM'] = 1
    else:
        X_c['AM/PM'] = 0
    for j in range(6, 6*24+1, 6):
        X_c[str(j) + '_10min'] = X_c.values[:, window - j : window].sum()
    X_c = X_c.astype(int)
    X_c['N_naps_12hrs'] = pd.Series(
        X_c.values[:, window - 72 : window].flatten()).diff().abs().sum()//2

    return X_c


def update_step(X, model, weights, window):
    '''
    Calculate the next step prediction and use it to return a dataframe
    containing vectors for the 6 most recent time intervals which is used
    to make further forecast

    :param X: dataframe with 6 vectors corresponding to 6 most recent
              time steps
    :param model: trained lgbm regressor
    :param weights: weights which are used to combine the predictions from the
                    previous six steps
    :param window: number of 10-minute intervals used to make a prediction
    :return: data over 6 steps ready to be plugged in to the model
    '''

    pred = prediction(X, model, weights, window)
    X_c = X[1:]
    new_row = data_augment(X[5:], pred, X[5:].time_of_day.values, window)
    X_c = pd.concat([X_c, new_row])

    return X_c


def lgbm_avg_prediction(X, model, weights, window, forecast_period):
    '''
    This function generates binary sleep forecast for the next
    'forecast period' number of 10-minute intervals

    :param X: dataframe with 6 vectors corresponding to 6 most recent
              time steps
    :param model: trained lgbm regressor
    :param weights: weights which are used to combine the predictions from the
                    previous six steps
    :param window: number of 10-minute intervals used to make a prediction
    :param forecast_period: number of steps to make a prediction for
    :return: binary series of sleep/awake states
    '''

    sleep = np.array(X.iloc[-1, window - 64 : window])

    for i in range(forecast_period):
        X = update_step(X, model, weights, window)
        sleep = np.append(sleep, X.iloc[-1, window - 1])

    return sleep


def forecast(sleep, time0, forecast_period):
    '''
    This function uses the result of the lgbm_avg_prediction function
    to generate a sleep/awake timeseries in an appropriate format

    :param sleep: sleep data generated by the load_data.get_sleep function
    :param time0: timestamp after which the forecast is being made
    :param forecast_period: number of steps to make a prediction for
    :return: binary time-series of sleep/awake states
    '''

    window = 6 * 24 * 6
    X_train, y_train, Xtt = prepare_data(sleep, window)
    model = train_model(X_train, y_train)

    weights = np.array([1, 1, 1, 1, 1.1, 1.25])

    futuresleep = lgbm_avg_prediction(Xtt, model, weights,
                                      window, forecast_period)

    times = pd.date_range(start=sleep.index[-65],
                          periods=64 + forecast_period, freq='10min')
    answer = pd.DataFrame(data=futuresleep, index=times, columns=['trend'])

    answer.index += time0 - answer.index[64]

    return answer


def predict_proba(sleep):
    '''
    This function performs a 1-step ahead predction returning the raw
    forecast generated by the model, without converting it to a
    binary number

    :param sleep: sleep data generated by the load_data.get_sleep function
    :return: real value between 0 and 1 corresponding to the
             next-step prediction
    '''

    window = 6 * 24 * 6
    X_train, y_train, Xtt = prepare_data(sleep, window)
    model = train_model(X_train, y_train)

    weights = np.array([1, 1, 1, 1, 1.1, 1.25])

    predval = prediction(Xtt, model, weights, window, rounding=False)

    if predval > 1:
        predval = 1
    if predval < 0:
        predval = 0

    return predval

